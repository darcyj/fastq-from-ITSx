#!/usr/local/bin/Rscript

# on linux, change the top line to /usr/bin/env Rscript

## Script Info: This program takes a fasta file that has been processed with ITSx, and 
	# adds quality scores from the original fastq file. 

## set up environment
	suppressPackageStartupMessages(require(optparse))
	suppressPackageStartupMessages(require(parallel))


## parse arguments
	option_list <- list(
		make_option(c("-f", "--fasta"), action="store", default=NA, type='character',
			help="Input fasta, ITSx output."), 
		make_option(c("-q", "--fastq"), action="store", default=NA, type='character',
			help="Input fastq, original file"),
		make_option(c("-o", "--output"), action="store", default=NA, type='character',
			help="Output fastq file path"),
		make_option(c("-t", "--threads"), action="store", default=4, type='integer',
			help="Number of CPU threads to use for parallel processing")
	) 
	opt = parse_args(OptionParser(option_list=option_list))


## some functions (these should really be in a separate file that i source() in, but I'm too lazy):
	# function to read in fasta or fastq file as list
	# NOTE: ONLY WORKS ON SEQUENTIAL FASTX FILES. 
	# Hope you aren't still using interleaved files after like 2005
	read.fastx <- function(file, type=c("fastq", "fasta")){
		# read in raw data
		lines <- scan(file, what="character", sep='\n')
		
		# check to make sure data are OK-ish
		nlines <- length(lines)
		if(type=="fastq" & nlines %% 4 > 0){
			stop("CRITICAL ERROR: number of lines in fastq file not divisible by 4.")
		}else if(type == "fasta" & nlines %% 2 > 0){
			stop("CRITICAL ERROR: number of lines in fasta file not divisible by 2")
		}

		# make indices for item types (1=header, 2=seq, 3="+", 4=qual)
		if(type=="fastq"){
			line_inds <- rep(1:4, nlines/4)
		}else if(type=="fasta"){
			line_inds <- rep(1:2, nlines/2)
		}

		# make names generic
		headers <- as.vector(sapply(X=lines[line_inds == 1], FUN=function(x) substring(x, 2) ) )

		# make output list object
		if(type=="fastq"){
			output <- mapply(FUN=c, lines[line_inds == 2], lines[line_inds == 4], SIMPLIFY=FALSE)
		}else if(type=="fasta"){
			output <- mapply(FUN=c, lines[line_inds == 2], SIMPLIFY=FALSE)
		}

		# add names to output list
		names(output) <- headers

		# all done
		return(output)

	}

	# function to wrout out a fasta or fastq file from a list as generated by read_fastx
	write.fastx <- function(outfile, fastxlist, out=c("fastq", "fasta")){
		# decide how to make header
		if(out=="fastq"){
			headchar <- "@"
		}else if(out=="fasta"){
			headchar <- ">"
		}

		# write out file, line-by-line
		for(i in 1:length(fastxlist)){
			firstline <- i == 1
			header_i <- paste(headchar, names(fastxlist[i]), sep="")

			# write header, don't append if it's the first line
			write(header_i, file=outfile, append=firstline==FALSE)

			# write sequence
			write(fastxlist[[i]][1], file=outfile, append=TRUE)

			# if fastq, write + and qual
			if(out=="fastq"){
				write("+", file=outfile, append=TRUE)
				write(fastxlist[[i]][2], file=outfile, append=TRUE)
			}
		}
	}


	# function to read a poorly-formatted fasta file
	# still won't work on interleaved files, though. Or files with line-breaks
	# other than \n.
	read.fasta.line.by.line <- function(fasta_fp){
		fasta_text <- scan(file=fasta_fp, what='character', sep='\n')
			
		firstchars <- sapply(X=fasta_text, FUN=substr, start=1, stop=1)
		nlines <- length(firstchars)
		
		# line_type will tell us what kind of line each line is
		# 1=header, 2=sequence, -1=badline, 0=unknown
		line_type <- rep(0, nlines)
		for(i in 1:(nlines - 1)){
			current_lt <- line_type[i]
			current_firstchar <- firstchars[i]
			next_firstchar <- firstchars[i+1]
			
			# check if line type has already been decided
			# (this loop will set future line types)
			if(current_lt == 0){
				if(current_firstchar == ">" & next_firstchar != ">"){
					line_type[i] <- 1
					line_type[i+1] <- 2			
				}else{
					line_type[i] <- -1
				}
			}	
		}

		# build fasta list output
		fasta_list <- as.list(fasta_text[line_type==2])
		output_headers <- substring(fasta_text[line_type == 1], 2)
		names(fasta_list) <- output_headers
		
		return(fasta_list)
	}

## read in ITSx fasta file
	itsx_fasta_list <- read.fasta.line.by.line(opt$fasta)

## read in original fastq file
	fastq_list <- read.fastx(opt$fastq, type="fastq")

## sort both lists alphabetically by header
	itsx_fasta_list <- itsx_fasta_list[order(names(itsx_fasta_list))]
	fastq_list <- fastq_list[order(names(fastq_list))]

## get rid of seqs not common to both lists
	shared_headers <- names(itsx_fasta_list)[ names(itsx_fasta_list) %in% names(fastq_list) ]
	itsx_fasta_list <- itsx_fasta_list[names(itsx_fasta_list) %in% shared_headers]
	fastq_list <- fastq_list[names(fastq_list) %in% shared_headers]

## merge lists
	# this makes a list where each item list[[i]] is as follows:
	# i[1]: extracted sequence from ITSx
	# i[2]: original raw sequence from fastq
	# i[3]: original quality scores for i[2]
	combined_list <- mapply(c, itsx_fasta_list, fastq_list, SIMPLIFY=FALSE)

## reverse-compliment function
	# x is a string of [ATGC], all upper case
	reverse.compliment <- function(x){
		# map for complimentary nucleotides
		comp_map <- setNames(c("A", "T", "G", "C"), c("T", "A", "C", "G"))
		# turn string x into character vector
		x <- unlist(strsplit(x, split=""))
		# reverse-compliment x
		x_rc <- rev(comp_map[unlist(x)])
		# return x_rc as string
		return(paste(x_rc, collapse=""))
	}

## function to apply over combined_list
	# this function extracts the quality scores that match up with the itsx extracted sequence
	# the function takes list[[i]] from above - a string array of length 3
	extract.quals <- function(x){
		# x[1]: ITSx extracted seq
		# x[2]: full seq
		# x[3]: quals for full seq
		
		# find where extracted seq is in full seq
		start_ind <- regexpr(pattern=x[1], text=x[2], fixed=TRUE)[1]

		# if it wasn't found, RC fastq stuff (not itsx seq)
		if(start_ind == -1){
			x[2] <- reverse.compliment(x[2])
			# qual scores are just reversed :)
			x[3] <- paste(rev(unlist(strsplit(x[3], split=""))), collapse="")
			# check again
			start_ind <- regexpr(pattern=x[1], text=x[2], fixed=TRUE)[1]

			# if it STILL isn't found, return seq as error so it can be removed later
			if(start_ind == -1){
				x[1] <- "seq_not_found"
			}else{
				stop_ind <- nchar(x[1]) + start_ind - 1
				quals <- substr(x[3], start=start_ind, stop=stop_ind)
			}
		# If it was found, get the quals without changing anything
		}else{
			stop_ind <- nchar(x[1]) + start_ind - 1
			quals <- substr(x[3], start=start_ind, stop=stop_ind)
		}

		return(c(x[1], quals))
	}
	# test code for above funtion, FWD
		#testx <- c("ATAAAGAGCAT", "AAATCAGCGCTACTAGCGCATCATAAAGAGCATATAGACAGATTTAGATTTAC", "CCCcCCCCCCCCCCCCCCCCCCGOODITWORKSCCCCCCCCCCCCCCCCCCCC")
		#extract.quals(testx)
		# test code for above function, REV
		#testx <- c("ATGCTCTTTAT", "AAATCAGCGCTACTAGCGCATCATAAAGAGCATATAGACAGATTTAGATTTAC", "CCCcCCCCCCCCCCCCCCCCCCSKROWTIDOOGCCCCCCCCCCCCCCCCCCCC")
		#extract.quals(testx)


## build output fasta file in parallel
	output <- mclapply(X=combined_list, FUN=extract.quals, mc.cores=opt$threads)

## remove items from output that failed to find
	identify_bad_seqs <- function(x){
		out <- "good"
		if(x[1] == "seq_not_found"){
			out <- "bad"
		}
		return(out)
	}
	badseqs <- lapply(X=output, FUN=identify_bad_seqs)
	output <- output[badseqs == "good"]


## write out fastq file
	write.fastx(outfile=opt$output, fastxlist=output, out="fastq")


